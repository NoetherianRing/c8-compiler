program -> block eof ( :D )

block ->  {statements} ( :D )

stmnts -> stmnt stmnts (:D)
        |stmnt (:D)
        | \n (:D)

stmnt -> declaration (:D)
        | var = expression (:D)
        | var = condition ?????
        | fn arg ident funcDataType block (:D)
        | if condition block else block
        | if condition block
        | while condition block
        | call (:))

*/

ident -> id (:D)

call ->| var(params) (:D)
        |var() (:D)


arg -> (paramDecl) (:))
       |() (:D)

declaration -> let ident datatype (:D)

paramDecl -> declaration, paramDecl (:D)
            | declaration (:D)

params -> expression, params (:D)
         |condition ???
         |expression (:D)

var ->  |*var (:D)
        |[literal] var (:D)
        |(var) (:D)
        |id (:D)


literal -> address (:D)
        |byte (:D)
        |bool (:D)

address -> &address (:D)
           |&var (:D)

funcDataType -> void (:D)
               |datatype (:))

dataType -> [literal]datatype (:D)
            |*datatype (:D)
            |typeBool(:D)
            |typeByte(:D)


/*
condition -> conditionTerm || condition
            |conditionTerm

conditionTerm -> logicalOperator && conditionTerm
                | logicalOperator

logicalOperator -> expresion == expression
                   |expresion < expresion
                   |expresion > expresion
                   |expresion <= expresion
                   |expresion >= expresion
*/

condition -> conditionB || condition
            |conditionB

conditionB -> conditionC &&  conditionB
             |conditionC


conditionC -> conditionD == conditionC
              |conditionD != conditionC
              |conditionD

conditionD -> expression < expression
            | expression <= expression
            | expression > expression
            | expression >= expression
            | expression
            | (condition)

expression -> expressionB | expression
             | expressionB

expressionB -> expressionC ^ expressionB
               |expressionC

expressionC -> expressionD & expressionC
              |expressionD

expressionD -> expressionE >> expressionD
              |expressionE << expressionD
              |expressionE

expressionE -> expressionF + expressionE
              |expressionF - expressionE
              |expressionF

expressionF -> expressionG + expressionF
            |expressionG - expressionF
            |expressionG

expressionG -> expressionH % expressionG
              |expressionH / expressionG
              |expressionH * expressionG
              |expressionH

expressionH -> literal
              |call
              |var
              |(expression)